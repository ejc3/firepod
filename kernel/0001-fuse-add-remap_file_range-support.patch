From 6f6ee8aeb45e73a6aa45538f1c663b9dd6e9d75e Mon Sep 17 00:00:00 2001
From: ejc3 <ejc3@users.noreply.github.com>
Date: Sat, 3 Jan 2026 23:05:43 +0000
Subject: [PATCH] fuse: add remap_file_range support for FICLONE

Add support for the remap_file_range file operation to FUSE, enabling
FICLONE and FICLONERANGE ioctls to work on FUSE filesystems.

This is useful for:
- Container filesystems that need to support btrfs-style reflinks
- Copy-on-write operations through FUSE passthrough filesystems
- Deduplication operations (with REMAP_FILE_DEDUP flag)

Signed-off-by: fcvm developers <fcvm@anthropic.com>
---
 fs/fuse/file.c            | 100 ++++++++++++++++++++++++++++++++++++++
 fs/fuse/fuse_i.h          |   3 ++
 include/uapi/linux/fuse.h |  17 +++++++
 3 files changed, 120 insertions(+)

diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 6014d5888..3762cd1a0 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -3104,6 +3104,105 @@ static ssize_t fuse_copy_file_range(struct file *src_file, loff_t src_off,
 	return ret;
 }
 
+
+static loff_t fuse_remap_file_range(struct file *file_in, loff_t pos_in,
+				    struct file *file_out, loff_t pos_out,
+				    loff_t len, unsigned int remap_flags)
+{
+	struct fuse_file *ff_in = file_in->private_data;
+	struct fuse_file *ff_out = file_out->private_data;
+	struct inode *inode_in = file_inode(file_in);
+	struct inode *inode_out = file_inode(file_out);
+	struct fuse_inode *fi_out = get_fuse_inode(inode_out);
+	struct fuse_mount *fm = ff_in->fm;
+	struct fuse_conn *fc = fm->fc;
+	FUSE_ARGS(args);
+	struct fuse_remap_file_range_in inarg = {
+		.fh_in = ff_in->fh,
+		.off_in = pos_in,
+		.nodeid_out = ff_out->nodeid,
+		.fh_out = ff_out->fh,
+		.off_out = pos_out,
+		.len = len,
+		.remap_flags = remap_flags,
+	};
+	struct fuse_write_out outarg;
+	loff_t err;
+	loff_t end_in, end_out;
+	bool is_unstable;
+
+	if (fc->no_remap_file_range)
+		return -EOPNOTSUPP;
+
+	if (file_inode(file_in)->i_sb != file_inode(file_out)->i_sb)
+		return -EXDEV;
+
+	if (len == 0) {
+		end_in = LLONG_MAX;
+		end_out = LLONG_MAX;
+	} else {
+		end_in = pos_in + len - 1;
+		end_out = pos_out + len - 1;
+	}
+
+	is_unstable = (!fc->writeback_cache) &&
+		      (len == 0 || (pos_out + len) > inode_out->i_size);
+
+	inode_lock(inode_in);
+	err = fuse_writeback_range(inode_in, pos_in, end_in);
+	inode_unlock(inode_in);
+	if (err)
+		return err;
+
+	inode_lock(inode_out);
+
+	err = file_modified(file_out);
+	if (err)
+		goto out;
+
+	err = fuse_writeback_range(inode_out, pos_out, end_out);
+	if (err)
+		goto out;
+
+	if (is_unstable)
+		set_bit(FUSE_I_SIZE_UNSTABLE, &fi_out->state);
+
+	args.opcode = FUSE_REMAP_FILE_RANGE;
+	args.nodeid = ff_in->nodeid;
+	args.in_numargs = 1;
+	args.in_args[0].size = sizeof(inarg);
+	args.in_args[0].value = &inarg;
+	args.out_numargs = 1;
+	args.out_args[0].size = sizeof(outarg);
+	args.out_args[0].value = &outarg;
+
+	err = fuse_simple_request(fm, &args);
+	if (err == -ENOSYS) {
+		fc->no_remap_file_range = 1;
+		err = -EOPNOTSUPP;
+		goto out;
+	}
+	if (err)
+		goto out;
+
+	truncate_inode_pages_range(inode_out->i_mapping,
+				   ALIGN_DOWN(pos_out, PAGE_SIZE),
+				   ALIGN(pos_out + outarg.size, PAGE_SIZE) - 1);
+
+	file_update_time(file_out);
+	fuse_write_update_attr(inode_out, pos_out + outarg.size, outarg.size);
+
+	err = outarg.size;
+out:
+	if (is_unstable)
+		clear_bit(FUSE_I_SIZE_UNSTABLE, &fi_out->state);
+
+	inode_unlock(inode_out);
+	file_accessed(file_in);
+	fuse_flush_time_update(inode_out);
+
+	return err;
+}
 static const struct file_operations fuse_file_operations = {
 	.llseek		= fuse_file_llseek,
 	.read_iter	= fuse_file_read_iter,
@@ -3123,6 +3222,7 @@ static const struct file_operations fuse_file_operations = {
 	.poll		= fuse_file_poll,
 	.fallocate	= fuse_file_fallocate,
 	.copy_file_range = fuse_copy_file_range,
+	.remap_file_range = fuse_remap_file_range,
 };
 
 static const struct address_space_operations fuse_file_aops  = {
diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h
index c2f2a4815..825d92f4f 100644
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -859,6 +859,9 @@ struct fuse_conn {
 	/** Does the filesystem support copy_file_range_64? */
 	unsigned no_copy_file_range_64:1;
 
+	/** Does the filesystem support remap_file_range (FICLONE)? */
+	unsigned no_remap_file_range:1;
+
 	/* Send DESTROY request */
 	unsigned int destroy:1;
 
diff --git a/include/uapi/linux/fuse.h b/include/uapi/linux/fuse.h
index c13e1f9a2..4ad264aa6 100644
--- a/include/uapi/linux/fuse.h
+++ b/include/uapi/linux/fuse.h
@@ -663,6 +663,7 @@ enum fuse_opcode {
 	FUSE_TMPFILE		= 51,
 	FUSE_STATX		= 52,
 	FUSE_COPY_FILE_RANGE_64	= 53,
+	FUSE_REMAP_FILE_RANGE	= 54,
 
 	/* CUSE specific operations */
 	CUSE_INIT		= 4096,
@@ -1308,4 +1309,20 @@ struct fuse_uring_cmd_req {
 	uint8_t padding[6];
 };
 
+
+/**
+ * struct fuse_remap_file_range_in - FUSE_REMAP_FILE_RANGE request
+ *
+ * Used for FICLONE/FICLONERANGE support through FUSE.
+ */
+struct fuse_remap_file_range_in {
+	uint64_t	fh_in;
+	uint64_t	off_in;
+	uint64_t	nodeid_out;
+	uint64_t	fh_out;
+	uint64_t	off_out;
+	uint64_t	len;
+	uint32_t	remap_flags;
+	uint32_t	padding;
+};
 #endif /* _LINUX_FUSE_H */
-- 
2.43.0

