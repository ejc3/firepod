From: fcvm <fcvm@localhost>
Subject: [PATCH] KVM: arm64: Add DSB before ioeventfd signaling for NV2

Under ARM64 nested virtualization with FEAT_NV2, when L2 (nested guest)
writes data to a virtqueue and then kicks via MMIO, the L1 hypervisor
may read stale data. This causes vsock stream corruption where ~32KB of
zeros appear after several megabytes of data transfer.

Add DSB SY immediately before kvm_io_bus_write() in io_mem_abort()
when running a nested guest. This ensures L2's prior data writes are
globally visible before we signal the eventfd that wakes userspace.

Signed-off-by: fcvm <fcvm@localhost>
---
 arch/arm64/kvm/mmio.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

--- a/arch/arm64/kvm/mmio.c
+++ b/arch/arm64/kvm/mmio.c
@@ -7,6 +7,7 @@
 #include <linux/kvm_host.h>
 #include <asm/kvm_emulate.h>
 #include <trace/events/kvm.h>
+#include <asm/barrier.h>

 #include "trace.h"

@@ -201,6 +202,15 @@ int io_mem_abort(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa)
 		trace_kvm_mmio(KVM_TRACE_MMIO_WRITE, len, fault_ipa, &data);
 		kvm_mmio_write_buf(data_buf, len, data);

+		/*
+		 * NV2 cache coherency: When running a nested guest,
+		 * ensure all prior guest writes are visible before
+		 * signaling the eventfd. Without this, userspace may
+		 * read stale data from guest memory.
+		 */
+		if (vcpu_has_nv(vcpu))
+			dsb(sy);
+
 		ret = kvm_io_bus_write(vcpu, KVM_MMIO_BUS, fault_ipa, len,
 				       data_buf);
 	} else {
